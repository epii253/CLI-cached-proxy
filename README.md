# Caching Proxy (look-through)

Простой учебный HTTP-прокси на C++, который пробрасывает запросы к одному заранее заданному origin, кеширует ответы в Redis и выполняет валидацию по `ETag` / учёт `Age`.  
Сделан как демонстрация практических бэкенд-навыков: работа с сокетами, HTTP-заголовками, многопоточность, интеграция с внешними библиотеками (cpr, redis++) и базовые принципы HTTP-кеширования.

> **Коротко:** клиент → `localhost:PORT` → **proxy** → (Redis cache) → origin.  
> Поддерживаемые методы: `GET`, `HEAD`, `POST` (без chunked).  
> Каждый клиент обрабатывается в своём `std::thread` (модель «один поток на соединение»).

---

## Содержание

- [Что делает проект](#что-делает-проект)  
- [Ключевые возможности](#ключевые-возможности)  
- [Архитектура](#архитектура)  
- [Чему этот проект учит (коротко)](#чему-этот-проект-учит-коротко)  
- [Ограничения / известные нюансы](#ограничения--известные-нюансы)  
- [Зависимости](#зависимости)  
- [Сборка](#сборка)  
- [Конфигурация](#конфигурация)  
- [Запуск (локально / Docker)](#запуск-локально--docker)  
- [Примеры использования (curl)](#примеры-использования-curl)  
- [Отладка и тестирование](#отладка-и-тестирование)  
- [Roadmap / идеи для улучшений](#roadmap--идеи-для-улучшений)  
- [Сопутствующие артефакты (systemd, docker-compose)](#сопутствующие-артефакты-systemd-docker-compose)  
- [Как внести вклад](#как-внести-вклад)  
- [Лицензия](#лицензия)

---

## Что делает проект

- Проксирует HTTP-запросы к одному origin.
- Кеширует ответы `GET` в Redis с TTL.
- Валидирует кеш по `ETag` (использует `If-None-Match` / обрабатывает `304 Not Modified`).
- Поддерживает учёт `Age` (сохраняется timestamp в кеше).
- Убирает hop-by-hop заголовки, корректно управляет `Content-Length` / `Transfer-Encoding` (в пределах текущей реализации).
- Логирует события: `accept`, `request`, `cache hit/miss`, ответ origin.

---

## Ключевые возможности

- Простая и понятная схема «look-through» проксирования.
- Кеширование в Redis с минимальной логикой invalidation.
- Подчёркнутое внимание на:
  - правильной работе с HTTP-заголовками (CRLF, hop-by-hop);
  - корректной пересылке тела и пересчёте заголовков при модификации;
  - использованию C++ многопоточности и безопасному shutdown.

---

## Архитектура

```
[Client] ---> [Proxy (localhost:PORT)] <---> [Redis cache] (store: body, headers, etag) ---> [Origin]
                  
```

Поток обработки (упрощённо):

1. `accept()` соединение → создаётся поток.
2. Парсинг стартовой строки/заголовков.
3. Для `GET`:
   - Проверка Redis по ключу (normalized URL).
   - Если hit и свежо → отдать из кеша.
   - Если hit и есть `ETag` → отправить `If-None-Match` к origin.
   - Если miss или origin дал новый контент → сохранить в Redis и отдать клиенту.
4. Для `POST`, `HEAD` — проксирование (POST буферизуется; chunked POST не поддерживается).

---

## Чему этот проект учит (коротко)

- низкоуровневому HTTP (формат запроса/ответа, CRLF, заголовки),
- работе с сокетами и `accept`/`read`/`write`,
- многопоточности на C++ (`std::thread`, безопасный shutdown / join),
- интеграции с внешними библиотеками: `cpr`/`libcurl` и `redis++`/`hiredis`,
- основам HTTP-кеширования: `ETag`, `If-None-Match`, `Age`, TTL, hop-by-hop заголовки.

Важно: это учебный проект — не претендует на полноту production-фич.

---

## Ограничения / известные нюансы

- Поддерживает `GET`, `HEAD`, `POST` (POST — без chunked, body буферизуется).
- Модель конкуренции: один поток на соединение → годится для низкой/средней нагрузки.
- Не реализована TLS-termination (HTTPS) — проксирование HTTPS через CONNECT не реализовано.
- Content-Encoding — данные принимаются в недекодированном формате (побайтово) и пересылаются на origin 
- Redis отвечает за кеширование; потеря Redis ведёт к тому, что кеш восстанавливается пустым (обычное поведение кеша).

---

## Зависимости

Минимальные:
- C++17 (gcc)
- CMake ≥ 3.12
- libcurl (dev)
- cpr (обертка над libcurl), либо можно напрямую использовать libcurl
- redis++ (redis-plus-plus) и hiredis
- Redis server для тестирования

---

## Конфигурация

Проект читает параметры из переменных окружения (или конфиг-файла, если реализовано):

- `PROXY_LISTEN_PORT` — порт прокси (по умолчанию `4000`)
- `ORIGIN_URL` — полный URL origin (например `http://example.com:80`)
- `REDIS_URL` — адрес Redis, например `tcp://127.0.0.1:6379`
- `CACHE_TTL` — TTL в секундах для кеша (по умолчанию, например, `300`)
- `LOG_LEVEL` — `info|debug|error`

Пример файла `example.env` (положите рядом и `export $(cat example.env)`):
```env
PROXY_LISTEN_PORT=4000
ORIGIN_URL=http://example-origin.local:80
REDIS_URL=tcp://127.0.0.1:6379
CACHE_TTL=300
LOG_LEVEL=info
```

---

## Запуск (локально)


### Пример запуска прокси (локально, после сборки)
```bash

./bin/caching-proxy --port 5000 --origin https://cppreference.com
```


## Roadmap / идеи для улучшений

- Ввести валидацию доступа к Redis серверу (локальному).
- Ручного управление кешем (Очищение по команде и точечное удаление по ключу).
- Добавить chunked возможность для POST (возможны ограничения библиотекой cpr).
---
